#!/usr/bin/python

# L. David Baron <dbaron@dbaron.org>, June 2011

# This work is available under the CC0 Public Domain Dedication:
# http://creativecommons.org/publicdomain/zero/1.0/
# To the extent possible under law, L. David Baron has waived all
# copyright and related or neighboring rights to the tz.js library,
# including the JavaScript code and the tools used to generate it.  This
# work is published from the United States of America.

# This script converts the compiled time zone data from the Olson time
# zone database (http://www.twinsun.com/tz/tz-link.htm), which is
# generated from the tzdata* data using the tzcode* code, and
# distributed on many Unix-ish operating systems in /usr/share/zoneinfo,
# into a JSON format suitable for inclusion in the tz.js JavaScript
# library.

import sys
import imp
import os.path
import subprocess
import re

__all__ = [
    "output_tests"
]

os.environ["LC_ALL"] = "C"
os.environ["LC_TIME"] = "C"

generate_zones = imp.load_source("compiled_to_json",
                                 os.path.join(os.path.dirname(__file__),
                                              "compiled-to-json.py")
                                 ).generate_zones
all_zones = map(None, generate_zones())

def output_tests(io):
    io.write("""<!DOCTYPE HTML>
<title>tz.js tests (generated by """ + __file__ + """)</title>
<script src="tz.js"></script>
<pre id="output"></pre>
<script>
/*
 * Generate tests based on all the transitions shown by zdump -v -c 2050
 * on each zone
 */

var output_node = document.createTextNode("");
document.getElementById("output").appendChild(output_node);
function print(s)
{
    output_node.appendData(s + "\\n");
}

var pass_count = 0, fail_count = 0;

function assert(cond, description)
{
    if (cond) {
        ++pass_count;
    } else {
        ++fail_count;
        print("FAIL: " + description);
    }
}

function is(value, expected, description)
{
    assert(value == expected,
           description + ":  " + value + " should equal " + expected);
}

function check_offset(zone, d, utcoff, abbr)
{
    var z = tz.zoneAt(zone, new Date(d * 1000));
    is(z.offset, utcoff, zone + " at " + d);
    is(z.abbr, abbr, zone + " at " + d);
}

""")
    for zone in all_zones:
        def output_test(d, utcoff, abbr):
            io.write("check_offset(\"{0}\", {1}, {2}, \"{3}\");\n" \
                       .format(zone, d, utcoff, abbr));
        zdump = subprocess.Popen(['zdump', '-v', '-c', '2050', zone],
                                 stdout=subprocess.PIPE)
        zdump_re = re.compile("^" + zone + "  ([^=]+) = ([^=]+) isdst=([01]) gmtoff=(-?\d+)$")
        first = True
        first_after_1970 = True
        prev_utcoff = None
        prev_abbr = None
        for line in zdump.stdout:
            line = line.rstrip("\n")
            if line.endswith(" = NULL"):
                continue
            (date_utc, date_loc, isdst, utcoff) = zdump_re.match(line).groups()
            isdst = bool(isdst) # not really needed
            utcoff = int(utcoff)
            date_process = subprocess.Popen(['date', '--date=' + date_utc,
                                             '+%s'],
                                            stdout = subprocess.PIPE)
            d = int(date_process.stdout.read().rstrip("\n"))
            date_process.stdout.close()
            abbr = date_loc.split(" ")[-1]
            if d < 0:
                first = False
                prev_utcoff = utcoff
                prev_abbr = abbr
                continue
            if first_after_1970 and d != 0 and not first:
                output_test(0, prev_utcoff, prev_abbr)
            if first and d > 0:
                output_test(0, utcoff, abbr)
            first_after_1970 = False
            first = False
            output_test(d, utcoff, abbr)
        zdump.stdout.close()
    io.write("""
print("Totals:  " + pass_count + " passed, " + fail_count + " failed.");
</script>
""")

if __name__ == '__main__':
    output_tests(sys.stdout)
