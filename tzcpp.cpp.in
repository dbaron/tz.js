#include <cctype>
#include <cstring>
#include <ctime>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include "tzcpp.h"

#include <iostream>

namespace tzcpp {

    namespace {
        struct ZoneInfoPriv {
            // data_ contains 7-bytes null-terminated abbreviation and the last byte is dst
            char data_[8];

            // Zone abbreviation
            const char* abbr() const {
                return data_;
            }

            // Is daylight saving time?
            bool is_dst() const {
                return data_[7] != 0;
            }

            int offset;

            ZoneInfoPriv(int o, const char* a, bool dst = false) : offset(o) {
                size_t l = std::strlen(a);
                if (l > 6)
                    l = 6; // TODO: warning???
                std::memset(data_, 0, sizeof(data_));
                std::memcpy(data_, a, l);
                data_[7] = dst;
            }

            ZoneInfoPriv(const ZoneInfoPriv&) = default;
            ZoneInfoPriv(ZoneInfoPriv&&) = default;
            ZoneInfoPriv& operator = (const ZoneInfoPriv&) = default;
            ZoneInfoPriv& operator = (ZoneInfoPriv&&) = default;
        };

        struct TimezoneInfoPriv {
            size_t info_idx;
            int64_t time;
        };

        struct TimezonePriv {
            size_t begin;
            size_t end;
            const char* rule;
        };

        static std::vector<ZoneInfoPriv> zone_rules = {
// @ZONE_RULES@
        };

        static std::vector<TimezoneInfoPriv> zones = {
// @ZONES@
        };

        static std::unordered_map<std::string, TimezonePriv> database = {
// @DATABASE@
        };

        static std::unordered_map<std::string, std::string> links = {
// @LINKS@
        };

        inline auto find_timezone(const char* zone, int64_t t, bool local_time = false) {
            auto it = database.find(zone);
            if (it == database.end()) {
                auto it2 = links.find(zone);
                if (it2 == links.end())
                    return zones.end();
                it = database.find(it2->second);
                if (it == database.end())
                    return zones.end();
            }
            auto begin = zones.begin() + it->second.begin;
            auto end = zones.begin() + it->second.end;

            auto zit = std::lower_bound(begin, end, t, [] (const TimezoneInfoPriv& a, int64_t b) {
                    return a.time < b;
            });
            if (zit == end) // extrapolate
                return std::prev(zit);

            if (local_time) {
                while (zit != begin && zit->time + zone_rules[zit->info_idx].offset >= t)
                    --zit;
            } else {
                while (zit != begin && zit->time > t)
                    --zit;
            }

            return zit;
        }

    } // anonymous namespace

    bool has_timezone(const std::string& tz) {
        return database.count(tz) || links.count(tz);
    }

    bool has_timezone(const char* tz) {
        return database.count(tz) || links.count(tz);
    }

    ZoneInfo get_timezone(const char* zone, int64_t t) {
        auto zit = find_timezone(zone, t);
        if (zit == zones.end())
            return ZoneInfo{};

        ZoneInfo res;
        res.offset = zone_rules[zit->info_idx].offset;
        res.abbr = zone_rules[zit->info_idx].abbr();
        res.is_dst = zone_rules[zit->info_idx].is_dst();

        return res;
    }

    ZoneInfo get_timezone(const std::string& z, int64_t t) {
        return get_timezone(z.c_str(), t);
    }

    const char* version() {
        return "@VERSION@";
    }

    const char* data_version() {
        return "@DATA_VERSION@";
    }

    int64_t from_utc(const std::string& tz, int64_t t) {
        return from_utc(tz.c_str(), t);
    }

    int64_t from_utc(const char* zone, int64_t t) {
        auto zit = find_timezone(zone, t);
        if (zit == zones.end())
            return t;

        return t + zone_rules[zit->info_idx].offset;
    }

    int64_t from_local(const std::string& tz, int64_t t) {
        return from_local(tz.c_str(), t);
    }

    int64_t from_local(const char* zone, int64_t t) {
        auto zit = find_timezone(zone, t, true);
        if (zit == zones.end())
            return t;

        return t - zone_rules[zit->info_idx].offset;
    }

} // namespace tzcpp
